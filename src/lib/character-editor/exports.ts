/**
 * Character ROM Editor - Export Formats
 *
 * Provides export to various formats:
 * - Binary ROM (existing)
 * - C/C++ Header
 * - Assembly Include
 * - PNG Image
 */

import {
  Character,
  CharacterSetConfig,
  bytesPerLine,
  bytesPerCharacter,
} from "./types";
import { characterToBytes } from "./binary";

/**
 * Export format types
 */
export type ExportFormat = "binary" | "c-header" | "assembly" | "png" | "reference-sheet";

/**
 * Export format metadata
 */
export interface ExportFormatInfo {
  id: ExportFormat;
  name: string;
  description: string;
  extension: string;
  mimeType: string;
}

/**
 * Available export formats
 */
export const EXPORT_FORMATS: ExportFormatInfo[] = [
  {
    id: "binary",
    name: "Binary ROM",
    description: "Raw binary data for direct ROM programming",
    extension: ".bin",
    mimeType: "application/octet-stream",
  },
  {
    id: "c-header",
    name: "C/C++ Header",
    description: "Byte array for embedded development",
    extension: ".h",
    mimeType: "text/x-c",
  },
  {
    id: "assembly",
    name: "Assembly Include",
    description: "Data bytes for 6502/Z80 assembly",
    extension: ".asm",
    mimeType: "text/plain",
  },
  {
    id: "png",
    name: "PNG Image",
    description: "Character sheet image",
    extension: ".png",
    mimeType: "image/png",
  },
  {
    id: "reference-sheet",
    name: "Reference Sheet",
    description: "Printable reference with character codes",
    extension: ".png",
    mimeType: "image/png",
  },
];

/**
 * C/C++ Header export options
 */
export interface CHeaderOptions {
  arrayName: string;
  includeGuards: boolean;
  includeComments: boolean;
  bytesPerLine: number;
}

/**
 * Assembly export options
 */
export interface AssemblyOptions {
  labelName: string;
  directive: ".byte" | "db" | ".db" | "DC.B";
  useHex: boolean;
  includeComments: boolean;
  bytesPerLine: number;
}

/**
 * PNG export options
 */
export interface PngOptions {
  columns: number;
  scale: number;
  showGrid: boolean;
  gridColor: string;
  foregroundColor: string;
  backgroundColor: string;
  transparent: boolean;
}

/**
 * Reference sheet export options
 */
export interface ReferenceSheetOptions {
  columns: number;
  scale: number;
  showHex: boolean;
  showDecimal: boolean;
  showAscii: boolean;
  foregroundColor: string;
  backgroundColor: string;
  labelColor: string;
  title: string;
  showTitle: boolean;
}

/**
 * Default C Header options
 */
export function getDefaultCHeaderOptions(name: string): CHeaderOptions {
  // Sanitize name for C identifier
  const sanitized = name
    .replace(/[^a-zA-Z0-9_]/g, "_")
    .replace(/^[0-9]/, "_$&")
    .toUpperCase();

  return {
    arrayName: sanitized || "CHARSET",
    includeGuards: true,
    includeComments: true,
    bytesPerLine: 8,
  };
}

/**
 * Default Assembly options
 */
export function getDefaultAssemblyOptions(name: string): AssemblyOptions {
  const sanitized = name
    .replace(/[^a-zA-Z0-9_]/g, "_")
    .replace(/^[0-9]/, "_$&")
    .toLowerCase();

  return {
    labelName: sanitized || "charset",
    directive: ".byte",
    useHex: true,
    includeComments: true,
    bytesPerLine: 8,
  };
}

/**
 * Default PNG options
 */
export function getDefaultPngOptions(): PngOptions {
  return {
    columns: 16,
    scale: 4,
    showGrid: true,
    gridColor: "#333333",
    foregroundColor: "#ffffff",
    backgroundColor: "#000000",
    transparent: false,
  };
}

/**
 * Default Reference Sheet options
 */
export function getDefaultReferenceSheetOptions(name: string): ReferenceSheetOptions {
  return {
    columns: 16,
    scale: 3,
    showHex: true,
    showDecimal: false,
    showAscii: true,
    foregroundColor: "#ffffff",
    backgroundColor: "#000000",
    labelColor: "#888888",
    title: name || "Character Set",
    showTitle: true,
  };
}

/**
 * Generate C/C++ header file content
 */
export function exportToCHeader(
  characters: Character[],
  config: CharacterSetConfig,
  options: CHeaderOptions
): string {
  const lines: string[] = [];
  const guardName = `${options.arrayName}_H`;
  const charSize = bytesPerCharacter(config);

  // Header comment
  if (options.includeComments) {
    lines.push("/**");
    lines.push(` * ${options.arrayName} - Character ROM Data`);
    lines.push(` * Generated by RetroStack Character ROM Editor`);
    lines.push(` * `);
    lines.push(` * Character dimensions: ${config.width}x${config.height}`);
    lines.push(` * Total characters: ${characters.length}`);
    lines.push(` * Bytes per character: ${charSize}`);
    lines.push(" */");
    lines.push("");
  }

  // Include guards
  if (options.includeGuards) {
    lines.push(`#ifndef ${guardName}`);
    lines.push(`#define ${guardName}`);
    lines.push("");
  }

  // Array declaration
  const totalBytes = characters.length * charSize;
  lines.push(
    `const unsigned char ${options.arrayName}[${totalBytes}] = {`
  );

  // Generate byte data
  for (let i = 0; i < characters.length; i++) {
    const bytes = characterToBytes(characters[i], config);
    const byteStrings: string[] = [];

    for (let j = 0; j < bytes.length; j++) {
      byteStrings.push(`0x${bytes[j].toString(16).padStart(2, "0").toUpperCase()}`);
    }

    // Split into lines
    for (let j = 0; j < byteStrings.length; j += options.bytesPerLine) {
      const chunk = byteStrings.slice(j, j + options.bytesPerLine);
      const isLast = i === characters.length - 1 && j + options.bytesPerLine >= byteStrings.length;
      const lineContent = `  ${chunk.join(", ")}${isLast ? "" : ","}`;

      if (options.includeComments && j === 0) {
        lines.push(`${lineContent}  /* Char ${i} */`);
      } else {
        lines.push(lineContent);
      }
    }
  }

  lines.push("};");
  lines.push("");

  // Close include guards
  if (options.includeGuards) {
    lines.push(`#endif /* ${guardName} */`);
    lines.push("");
  }

  return lines.join("\n");
}

/**
 * Generate assembly include file content
 */
export function exportToAssembly(
  characters: Character[],
  config: CharacterSetConfig,
  options: AssemblyOptions
): string {
  const lines: string[] = [];
  const charSize = bytesPerCharacter(config);

  // Header comment
  if (options.includeComments) {
    lines.push("; " + "=".repeat(60));
    lines.push(`; ${options.labelName} - Character ROM Data`);
    lines.push("; Generated by RetroStack Character ROM Editor");
    lines.push("; ");
    lines.push(`; Character dimensions: ${config.width}x${config.height}`);
    lines.push(`; Total characters: ${characters.length}`);
    lines.push(`; Bytes per character: ${charSize}`);
    lines.push("; " + "=".repeat(60));
    lines.push("");
  }

  // Label
  lines.push(`${options.labelName}:`);

  // Generate byte data
  for (let i = 0; i < characters.length; i++) {
    const bytes = characterToBytes(characters[i], config);
    const byteStrings: string[] = [];

    for (let j = 0; j < bytes.length; j++) {
      if (options.useHex) {
        byteStrings.push(`$${bytes[j].toString(16).padStart(2, "0").toUpperCase()}`);
      } else {
        byteStrings.push(bytes[j].toString());
      }
    }

    // Split into lines
    for (let j = 0; j < byteStrings.length; j += options.bytesPerLine) {
      const chunk = byteStrings.slice(j, j + options.bytesPerLine);
      const lineContent = `    ${options.directive} ${chunk.join(", ")}`;

      if (options.includeComments && j === 0) {
        lines.push(`${lineContent}  ; Char ${i}`);
      } else {
        lines.push(lineContent);
      }
    }
  }

  lines.push("");

  return lines.join("\n");
}

/**
 * Generate PNG image as data URL
 * Returns a promise that resolves to a data URL
 */
export async function exportToPng(
  characters: Character[],
  config: CharacterSetConfig,
  options: PngOptions
): Promise<Blob> {
  const { columns, scale, showGrid, gridColor, foregroundColor, backgroundColor, transparent } =
    options;

  const rows = Math.ceil(characters.length / columns);
  const charWidth = config.width;
  const charHeight = config.height;

  // Calculate canvas size
  const gridThickness = showGrid ? 1 : 0;
  const canvasWidth =
    columns * charWidth * scale + (showGrid ? (columns + 1) * gridThickness : 0);
  const canvasHeight =
    rows * charHeight * scale + (showGrid ? (rows + 1) * gridThickness : 0);

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;
  const ctx = canvas.getContext("2d");

  if (!ctx) {
    throw new Error("Could not create canvas context");
  }

  // Fill background
  if (transparent) {
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
  } else {
    ctx.fillStyle = backgroundColor;
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
  }

  // Draw grid lines if enabled
  if (showGrid) {
    ctx.fillStyle = gridColor;

    // Vertical lines
    for (let col = 0; col <= columns; col++) {
      const x = col * (charWidth * scale + gridThickness);
      ctx.fillRect(x, 0, gridThickness, canvasHeight);
    }

    // Horizontal lines
    for (let row = 0; row <= rows; row++) {
      const y = row * (charHeight * scale + gridThickness);
      ctx.fillRect(0, y, canvasWidth, gridThickness);
    }
  }

  // Draw characters
  for (let i = 0; i < characters.length; i++) {
    const character = characters[i];
    const col = i % columns;
    const row = Math.floor(i / columns);

    const baseX = showGrid
      ? col * (charWidth * scale + gridThickness) + gridThickness
      : col * charWidth * scale;
    const baseY = showGrid
      ? row * (charHeight * scale + gridThickness) + gridThickness
      : row * charHeight * scale;

    // Draw character pixels
    for (let py = 0; py < charHeight; py++) {
      for (let px = 0; px < charWidth; px++) {
        const isOn = character.pixels[py]?.[px] || false;

        if (isOn) {
          ctx.fillStyle = foregroundColor;
          ctx.fillRect(baseX + px * scale, baseY + py * scale, scale, scale);
        } else if (!transparent) {
          ctx.fillStyle = backgroundColor;
          ctx.fillRect(baseX + px * scale, baseY + py * scale, scale, scale);
        }
      }
    }
  }

  // Convert to blob
  return new Promise((resolve, reject) => {
    canvas.toBlob(
      (blob) => {
        if (blob) {
          resolve(blob);
        } else {
          reject(new Error("Failed to create PNG blob"));
        }
      },
      "image/png"
    );
  });
}

/**
 * Get printable ASCII character or control code name
 */
function getAsciiLabel(code: number): string {
  if (code >= 32 && code <= 126) {
    return String.fromCharCode(code);
  }
  // Control characters
  const controlNames: Record<number, string> = {
    0: "NUL", 1: "SOH", 2: "STX", 3: "ETX", 4: "EOT", 5: "ENQ", 6: "ACK", 7: "BEL",
    8: "BS", 9: "TAB", 10: "LF", 11: "VT", 12: "FF", 13: "CR", 14: "SO", 15: "SI",
    16: "DLE", 17: "DC1", 18: "DC2", 19: "DC3", 20: "DC4", 21: "NAK", 22: "SYN", 23: "ETB",
    24: "CAN", 25: "EM", 26: "SUB", 27: "ESC", 28: "FS", 29: "GS", 30: "RS", 31: "US",
    127: "DEL",
  };
  return controlNames[code] || "";
}

/**
 * Generate Reference Sheet PNG
 * Creates a printable reference with character codes
 */
export async function exportToReferenceSheet(
  characters: Character[],
  config: CharacterSetConfig,
  options: ReferenceSheetOptions
): Promise<Blob> {
  const {
    columns,
    scale,
    showHex,
    showDecimal,
    showAscii,
    foregroundColor,
    backgroundColor,
    labelColor,
    title,
    showTitle,
  } = options;

  const rows = Math.ceil(characters.length / columns);
  const charWidth = config.width;
  const charHeight = config.height;

  // Calculate dimensions
  const cellPadding = 4;
  const labelHeight = 14; // Height for labels below character
  const labelLines = (showHex ? 1 : 0) + (showDecimal ? 1 : 0) + (showAscii ? 1 : 0);
  const totalLabelHeight = labelHeight * Math.max(1, labelLines);

  const cellWidth = charWidth * scale + cellPadding * 2;
  const cellHeight = charHeight * scale + cellPadding * 2 + totalLabelHeight;

  // Header dimensions
  const headerHeight = showTitle ? 40 : 0;
  const rowHeaderWidth = 40; // For row numbers (hex)
  const colHeaderHeight = 20; // For column numbers (hex)

  const canvasWidth = rowHeaderWidth + columns * cellWidth + cellPadding;
  const canvasHeight = headerHeight + colHeaderHeight + rows * cellHeight + cellPadding;

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;
  const ctx = canvas.getContext("2d");

  if (!ctx) {
    throw new Error("Could not create canvas context");
  }

  // Fill background
  ctx.fillStyle = "#1a1a2e"; // Dark retro background
  ctx.fillRect(0, 0, canvasWidth, canvasHeight);

  // Draw title
  if (showTitle && title) {
    ctx.fillStyle = foregroundColor;
    ctx.font = "bold 16px monospace";
    ctx.textAlign = "center";
    ctx.fillText(title, canvasWidth / 2, 26);

    // Subtitle with dimensions
    ctx.fillStyle = labelColor;
    ctx.font = "10px monospace";
    ctx.fillText(
      `${characters.length} characters, ${charWidth}x${charHeight} pixels`,
      canvasWidth / 2,
      38
    );
  }

  // Draw column headers
  ctx.fillStyle = labelColor;
  ctx.font = "10px monospace";
  ctx.textAlign = "center";
  for (let col = 0; col < columns; col++) {
    const x = rowHeaderWidth + col * cellWidth + cellWidth / 2;
    const y = headerHeight + colHeaderHeight - 6;
    ctx.fillText(col.toString(16).toUpperCase(), x, y);
  }

  // Draw row headers
  ctx.textAlign = "right";
  for (let row = 0; row < rows; row++) {
    const x = rowHeaderWidth - 8;
    const y = headerHeight + colHeaderHeight + row * cellHeight + cellHeight / 2;
    const rowValue = row * columns;
    ctx.fillText(rowValue.toString(16).toUpperCase().padStart(2, "0") + "_", x, y);
  }

  // Draw characters
  for (let i = 0; i < characters.length; i++) {
    const character = characters[i];
    const col = i % columns;
    const row = Math.floor(i / columns);

    const cellX = rowHeaderWidth + col * cellWidth;
    const cellY = headerHeight + colHeaderHeight + row * cellHeight;

    // Draw cell background
    ctx.fillStyle = backgroundColor;
    ctx.fillRect(
      cellX + 1,
      cellY + 1,
      cellWidth - 2,
      charHeight * scale + cellPadding * 2 - 2
    );

    // Draw character pixels
    const charX = cellX + cellPadding;
    const charY = cellY + cellPadding;

    for (let py = 0; py < charHeight; py++) {
      for (let px = 0; px < charWidth; px++) {
        const isOn = character.pixels[py]?.[px] || false;
        if (isOn) {
          ctx.fillStyle = foregroundColor;
          ctx.fillRect(charX + px * scale, charY + py * scale, scale, scale);
        }
      }
    }

    // Draw labels
    ctx.fillStyle = labelColor;
    ctx.font = "9px monospace";
    ctx.textAlign = "center";

    let labelY = cellY + cellPadding + charHeight * scale + 12;
    const labelX = cellX + cellWidth / 2;

    if (showHex) {
      ctx.fillText(
        "$" + i.toString(16).toUpperCase().padStart(2, "0"),
        labelX,
        labelY
      );
      labelY += 10;
    }

    if (showDecimal) {
      ctx.fillText(i.toString(), labelX, labelY);
      labelY += 10;
    }

    if (showAscii) {
      const asciiLabel = getAsciiLabel(i);
      if (asciiLabel) {
        ctx.fillStyle = i >= 32 && i <= 126 ? foregroundColor : "#666666";
        ctx.fillText(asciiLabel, labelX, labelY);
      }
    }
  }

  // Draw border
  ctx.strokeStyle = labelColor;
  ctx.lineWidth = 1;
  ctx.strokeRect(0.5, 0.5, canvasWidth - 1, canvasHeight - 1);

  // Add footer with generator info
  ctx.fillStyle = "#444444";
  ctx.font = "8px monospace";
  ctx.textAlign = "right";
  ctx.fillText(
    "Generated by RetroStack Character ROM Editor",
    canvasWidth - 8,
    canvasHeight - 4
  );

  // Convert to blob
  return new Promise((resolve, reject) => {
    canvas.toBlob(
      (blob) => {
        if (blob) {
          resolve(blob);
        } else {
          reject(new Error("Failed to create PNG blob"));
        }
      },
      "image/png"
    );
  });
}

/**
 * Get hex preview of first N bytes
 */
export function getHexPreview(
  characters: Character[],
  config: CharacterSetConfig,
  maxBytes: number = 16
): string {
  if (characters.length === 0) return "";

  const bytes: number[] = [];
  let charIndex = 0;

  while (bytes.length < maxBytes && charIndex < characters.length) {
    const charBytes = characterToBytes(characters[charIndex], config);
    for (let i = 0; i < charBytes.length && bytes.length < maxBytes; i++) {
      bytes.push(charBytes[i]);
    }
    charIndex++;
  }

  return bytes.map((b) => b.toString(16).padStart(2, "0").toUpperCase()).join(" ");
}

/**
 * Generate a sample row visualization showing bit layout
 */
export function getBitLayoutVisualization(
  character: Character,
  config: CharacterSetConfig,
  row: number = 0
): { bits: string; hex: string; padding: string } {
  const bytes = characterToBytes(character, config);
  const bpl = bytesPerLine(config.width);
  const rowBytes = bytes.slice(row * bpl, (row + 1) * bpl);

  // Get bits as string
  let bits = "";
  for (const byte of rowBytes) {
    bits += byte.toString(2).padStart(8, "0");
  }

  // Mark padding bits
  const totalBits = bpl * 8;
  const paddingBits = totalBits - config.width;
  let padding = "";

  if (config.padding === "left") {
    padding = "P".repeat(paddingBits) + "D".repeat(config.width);
  } else {
    padding = "D".repeat(config.width) + "P".repeat(paddingBits);
  }

  // Get hex representation
  const hex = Array.from(rowBytes)
    .map((b) => b.toString(16).padStart(2, "0").toUpperCase())
    .join(" ");

  return { bits, hex, padding };
}
