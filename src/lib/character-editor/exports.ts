/**
 * Character ROM Editor - Export Formats
 *
 * Provides export to various formats:
 * - Binary ROM (existing)
 * - C/C++ Header
 * - Assembly Include
 * - PNG Image
 */

import {
  Character,
  CharacterSetConfig,
  bytesPerLine,
  bytesPerCharacter,
} from "./types";
import { characterToBytes } from "./binary";

/**
 * Export format types
 */
export type ExportFormat = "binary" | "c-header" | "assembly" | "png";

/**
 * Export format metadata
 */
export interface ExportFormatInfo {
  id: ExportFormat;
  name: string;
  description: string;
  extension: string;
  mimeType: string;
}

/**
 * Available export formats
 */
export const EXPORT_FORMATS: ExportFormatInfo[] = [
  {
    id: "binary",
    name: "Binary ROM",
    description: "Raw binary data for direct ROM programming",
    extension: ".bin",
    mimeType: "application/octet-stream",
  },
  {
    id: "c-header",
    name: "C/C++ Header",
    description: "Byte array for embedded development",
    extension: ".h",
    mimeType: "text/x-c",
  },
  {
    id: "assembly",
    name: "Assembly Include",
    description: "Data bytes for 6502/Z80 assembly",
    extension: ".asm",
    mimeType: "text/plain",
  },
  {
    id: "png",
    name: "PNG Image",
    description: "Character sheet image",
    extension: ".png",
    mimeType: "image/png",
  },
];

/**
 * C/C++ Header export options
 */
export interface CHeaderOptions {
  arrayName: string;
  includeGuards: boolean;
  includeComments: boolean;
  bytesPerLine: number;
}

/**
 * Assembly export options
 */
export interface AssemblyOptions {
  labelName: string;
  directive: ".byte" | "db" | ".db" | "DC.B";
  useHex: boolean;
  includeComments: boolean;
  bytesPerLine: number;
}

/**
 * PNG export options
 */
export interface PngOptions {
  columns: number;
  scale: number;
  showGrid: boolean;
  gridColor: string;
  foregroundColor: string;
  backgroundColor: string;
  transparent: boolean;
}

/**
 * Default C Header options
 */
export function getDefaultCHeaderOptions(name: string): CHeaderOptions {
  // Sanitize name for C identifier
  const sanitized = name
    .replace(/[^a-zA-Z0-9_]/g, "_")
    .replace(/^[0-9]/, "_$&")
    .toUpperCase();

  return {
    arrayName: sanitized || "CHARSET",
    includeGuards: true,
    includeComments: true,
    bytesPerLine: 8,
  };
}

/**
 * Default Assembly options
 */
export function getDefaultAssemblyOptions(name: string): AssemblyOptions {
  const sanitized = name
    .replace(/[^a-zA-Z0-9_]/g, "_")
    .replace(/^[0-9]/, "_$&")
    .toLowerCase();

  return {
    labelName: sanitized || "charset",
    directive: ".byte",
    useHex: true,
    includeComments: true,
    bytesPerLine: 8,
  };
}

/**
 * Default PNG options
 */
export function getDefaultPngOptions(): PngOptions {
  return {
    columns: 16,
    scale: 4,
    showGrid: true,
    gridColor: "#333333",
    foregroundColor: "#ffffff",
    backgroundColor: "#000000",
    transparent: false,
  };
}

/**
 * Generate C/C++ header file content
 */
export function exportToCHeader(
  characters: Character[],
  config: CharacterSetConfig,
  options: CHeaderOptions
): string {
  const lines: string[] = [];
  const guardName = `${options.arrayName}_H`;
  const charSize = bytesPerCharacter(config);

  // Header comment
  if (options.includeComments) {
    lines.push("/**");
    lines.push(` * ${options.arrayName} - Character ROM Data`);
    lines.push(` * Generated by RetroStack Character ROM Editor`);
    lines.push(` * `);
    lines.push(` * Character dimensions: ${config.width}x${config.height}`);
    lines.push(` * Total characters: ${characters.length}`);
    lines.push(` * Bytes per character: ${charSize}`);
    lines.push(" */");
    lines.push("");
  }

  // Include guards
  if (options.includeGuards) {
    lines.push(`#ifndef ${guardName}`);
    lines.push(`#define ${guardName}`);
    lines.push("");
  }

  // Array declaration
  const totalBytes = characters.length * charSize;
  lines.push(
    `const unsigned char ${options.arrayName}[${totalBytes}] = {`
  );

  // Generate byte data
  for (let i = 0; i < characters.length; i++) {
    const bytes = characterToBytes(characters[i], config);
    const byteStrings: string[] = [];

    for (let j = 0; j < bytes.length; j++) {
      byteStrings.push(`0x${bytes[j].toString(16).padStart(2, "0").toUpperCase()}`);
    }

    // Split into lines
    for (let j = 0; j < byteStrings.length; j += options.bytesPerLine) {
      const chunk = byteStrings.slice(j, j + options.bytesPerLine);
      const isLast = i === characters.length - 1 && j + options.bytesPerLine >= byteStrings.length;
      const lineContent = `  ${chunk.join(", ")}${isLast ? "" : ","}`;

      if (options.includeComments && j === 0) {
        lines.push(`${lineContent}  /* Char ${i} */`);
      } else {
        lines.push(lineContent);
      }
    }
  }

  lines.push("};");
  lines.push("");

  // Close include guards
  if (options.includeGuards) {
    lines.push(`#endif /* ${guardName} */`);
    lines.push("");
  }

  return lines.join("\n");
}

/**
 * Generate assembly include file content
 */
export function exportToAssembly(
  characters: Character[],
  config: CharacterSetConfig,
  options: AssemblyOptions
): string {
  const lines: string[] = [];
  const charSize = bytesPerCharacter(config);

  // Header comment
  if (options.includeComments) {
    lines.push("; " + "=".repeat(60));
    lines.push(`; ${options.labelName} - Character ROM Data`);
    lines.push("; Generated by RetroStack Character ROM Editor");
    lines.push("; ");
    lines.push(`; Character dimensions: ${config.width}x${config.height}`);
    lines.push(`; Total characters: ${characters.length}`);
    lines.push(`; Bytes per character: ${charSize}`);
    lines.push("; " + "=".repeat(60));
    lines.push("");
  }

  // Label
  lines.push(`${options.labelName}:`);

  // Generate byte data
  for (let i = 0; i < characters.length; i++) {
    const bytes = characterToBytes(characters[i], config);
    const byteStrings: string[] = [];

    for (let j = 0; j < bytes.length; j++) {
      if (options.useHex) {
        byteStrings.push(`$${bytes[j].toString(16).padStart(2, "0").toUpperCase()}`);
      } else {
        byteStrings.push(bytes[j].toString());
      }
    }

    // Split into lines
    for (let j = 0; j < byteStrings.length; j += options.bytesPerLine) {
      const chunk = byteStrings.slice(j, j + options.bytesPerLine);
      const lineContent = `    ${options.directive} ${chunk.join(", ")}`;

      if (options.includeComments && j === 0) {
        lines.push(`${lineContent}  ; Char ${i}`);
      } else {
        lines.push(lineContent);
      }
    }
  }

  lines.push("");

  return lines.join("\n");
}

/**
 * Generate PNG image as data URL
 * Returns a promise that resolves to a data URL
 */
export async function exportToPng(
  characters: Character[],
  config: CharacterSetConfig,
  options: PngOptions
): Promise<Blob> {
  const { columns, scale, showGrid, gridColor, foregroundColor, backgroundColor, transparent } =
    options;

  const rows = Math.ceil(characters.length / columns);
  const charWidth = config.width;
  const charHeight = config.height;

  // Calculate canvas size
  const gridThickness = showGrid ? 1 : 0;
  const canvasWidth =
    columns * charWidth * scale + (showGrid ? (columns + 1) * gridThickness : 0);
  const canvasHeight =
    rows * charHeight * scale + (showGrid ? (rows + 1) * gridThickness : 0);

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;
  const ctx = canvas.getContext("2d");

  if (!ctx) {
    throw new Error("Could not create canvas context");
  }

  // Fill background
  if (transparent) {
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
  } else {
    ctx.fillStyle = backgroundColor;
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
  }

  // Draw grid lines if enabled
  if (showGrid) {
    ctx.fillStyle = gridColor;

    // Vertical lines
    for (let col = 0; col <= columns; col++) {
      const x = col * (charWidth * scale + gridThickness);
      ctx.fillRect(x, 0, gridThickness, canvasHeight);
    }

    // Horizontal lines
    for (let row = 0; row <= rows; row++) {
      const y = row * (charHeight * scale + gridThickness);
      ctx.fillRect(0, y, canvasWidth, gridThickness);
    }
  }

  // Draw characters
  for (let i = 0; i < characters.length; i++) {
    const character = characters[i];
    const col = i % columns;
    const row = Math.floor(i / columns);

    const baseX = showGrid
      ? col * (charWidth * scale + gridThickness) + gridThickness
      : col * charWidth * scale;
    const baseY = showGrid
      ? row * (charHeight * scale + gridThickness) + gridThickness
      : row * charHeight * scale;

    // Draw character pixels
    for (let py = 0; py < charHeight; py++) {
      for (let px = 0; px < charWidth; px++) {
        const isOn = character.pixels[py]?.[px] || false;

        if (isOn) {
          ctx.fillStyle = foregroundColor;
          ctx.fillRect(baseX + px * scale, baseY + py * scale, scale, scale);
        } else if (!transparent) {
          ctx.fillStyle = backgroundColor;
          ctx.fillRect(baseX + px * scale, baseY + py * scale, scale, scale);
        }
      }
    }
  }

  // Convert to blob
  return new Promise((resolve, reject) => {
    canvas.toBlob(
      (blob) => {
        if (blob) {
          resolve(blob);
        } else {
          reject(new Error("Failed to create PNG blob"));
        }
      },
      "image/png"
    );
  });
}

/**
 * Get hex preview of first N bytes
 */
export function getHexPreview(
  characters: Character[],
  config: CharacterSetConfig,
  maxBytes: number = 16
): string {
  if (characters.length === 0) return "";

  const bytes: number[] = [];
  let charIndex = 0;

  while (bytes.length < maxBytes && charIndex < characters.length) {
    const charBytes = characterToBytes(characters[charIndex], config);
    for (let i = 0; i < charBytes.length && bytes.length < maxBytes; i++) {
      bytes.push(charBytes[i]);
    }
    charIndex++;
  }

  return bytes.map((b) => b.toString(16).padStart(2, "0").toUpperCase()).join(" ");
}

/**
 * Generate a sample row visualization showing bit layout
 */
export function getBitLayoutVisualization(
  character: Character,
  config: CharacterSetConfig,
  row: number = 0
): { bits: string; hex: string; padding: string } {
  const bytes = characterToBytes(character, config);
  const bpl = bytesPerLine(config.width);
  const rowBytes = bytes.slice(row * bpl, (row + 1) * bpl);

  // Get bits as string
  let bits = "";
  for (const byte of rowBytes) {
    bits += byte.toString(2).padStart(8, "0");
  }

  // Mark padding bits
  const totalBits = bpl * 8;
  const paddingBits = totalBits - config.width;
  let padding = "";

  if (config.padding === "left") {
    padding = "P".repeat(paddingBits) + "D".repeat(config.width);
  } else {
    padding = "D".repeat(config.width) + "P".repeat(paddingBits);
  }

  // Get hex representation
  const hex = Array.from(rowBytes)
    .map((b) => b.toString(16).padStart(2, "0").toUpperCase())
    .join(" ");

  return { bits, hex, padding };
}
